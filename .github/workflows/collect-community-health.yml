name: Collect Community Health Metrics

on:
  schedule:
    # Runs daily at 3:00 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch: # Allows manual trigger

permissions:
  contents: write

jobs:
  collect-health-metrics:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Collect community health metrics
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create data directory if it doesn't exist
          mkdir -p community-health-dashboard/data/history

          # Create inline Node.js script to fetch community health metrics
          cat > collect-health-data.js << 'SCRIPT_EOF'
          const https = require('https');
          const fs = require('fs');

          // Load dashboard config to get repository list
          const configContent = fs.readFileSync('community-health-dashboard/config.js', 'utf8');

          // Extract repositories array from config.js
          const repoMatch = configContent.match(/repositories:\s*\[([\s\S]*?)\]/);
          if (!repoMatch) {
            console.error('Could not parse repositories from config.js');
            process.exit(1);
          }

          // Parse repository entries
          const repoEntries = repoMatch[1].match(/\{\s*org:\s*['"]([\w-]+)['"]\s*,\s*repo:\s*['"]([^'"]+)['"]\s*\}/g);
          if (!repoEntries) {
            console.error('No repositories found in config');
            process.exit(1);
          }

          const repositories = repoEntries.map(entry => {
            const orgMatch = entry.match(/org:\s*['"]([\w-]+)['"]/);
            const repoMatch = entry.match(/repo:\s*['"]([^'"]+)['"]/);
            return { org: orgMatch[1], repo: repoMatch[1] };
          });

          console.log(`Collecting health metrics from ${repositories.length} repositories...`);

          const token = process.env.GITHUB_TOKEN;
          const data = {
            timestamp: new Date().toISOString(),
            date: new Date().toISOString().split('T')[0],
            repositories: [],
            metrics: {}
          };

          // Date calculations
          const now = new Date();
          const contributorsPeriod = new Date(now - 90 * 24 * 60 * 60 * 1000);
          const newContribPeriod = new Date(now - 30 * 24 * 60 * 60 * 1000);
          const responseTimePeriod = new Date(now - 30 * 24 * 60 * 60 * 1000);

          function httpsRequest(options) {
            return new Promise((resolve, reject) => {
              const req = https.get(options, (res) => {
                let body = '';
                res.on('data', (chunk) => body += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    try {
                      resolve(JSON.parse(body));
                    } catch (err) {
                      reject(new Error(`Failed to parse JSON: ${err.message}`));
                    }
                  } else {
                    resolve(null);
                  }
                });
              }).on('error', reject);

              req.setTimeout(10000, () => {
                req.destroy();
                reject(new Error('Request timeout'));
              });
            });
          }

          /**
           * Parse Codecov badge SVG to extract coverage percentage
           *
           * NOTE: This logic is duplicated in community-health-dashboard/app.js
           * If you update this function, please update the dashboard as well to keep them in sync.
           *
           * Why SVG parsing instead of API:
           * - Codecov API v2 requires authentication (bearer token)
           * - Badge SVG endpoint is public and doesn't require auth
           * - Simpler implementation without token management
           * - Badge SVGs are designed to be publicly accessible
           *
           * Alternative: Use Codecov API v2 if auth tokens become available:
           * GET https://codecov.io/api/v2/github/{org}/repos/{repo}/commits
           * Returns array of commits with totals.coverage field
           *
           * @param {string} svgText - The SVG text from Codecov badge
           * @returns {number|null} - Coverage percentage (0-100) or null if unavailable
           */
          function parseCodecovBadge(svgText) {
            // Look for the coverage text in SVG text elements with y="14" (the visible text)
            // Format: <text x="93" y="14">37%</text> or <text x="93" y="14">unknown</text>
            const textMatch = svgText.match(/<text[^>]*y="14"[^>]*>([^<]+)<\/text>/g);
            if (textMatch && textMatch.length > 0) {
              // Get the last text element (which contains the coverage percentage)
              const lastText = textMatch[textMatch.length - 1];
              const coverageMatch = lastText.match(/>(\d+(?:\.\d+)?%|unknown)</);
              if (coverageMatch) {
                const value = coverageMatch[1];
                if (value === 'unknown') {
                  return null; // No coverage data
                } else {
                  return parseFloat(value);
                }
              }
            }
            return null;
          }

          /**
           * Fetch Snyk security vulnerability data for a repository
           *
           * Requires SNYK_API_TOKEN and SNYK_ORG_ID environment variables.
           * Returns vulnerability counts by severity or null if unavailable.
           *
           * @param {string} org - GitHub organization
           * @param {string} repo - Repository name
           * @returns {Object|null} - {critical, high, medium, low, total} or null
           */
          async function fetchSnykData(org, repo) {
            const snykOrgId = process.env.SNYK_ORG_ID;
            const snykToken = process.env.SNYK_API_TOKEN;

            if (!snykToken || !snykOrgId) {
              return null; // Snyk not configured
            }

            try {
              // 1. Get list of projects to find the matching GitHub repo
              const projectsData = await httpsRequest({
                hostname: 'api.snyk.io',
                path: `/v1/org/${snykOrgId}/projects`,
                headers: {
                  'Authorization': `token ${snykToken}`,
                  'Content-Type': 'application/json'
                }
              });

              if (!projectsData || !projectsData.projects) {
                return null;
              }

              // Find matching GitHub project
              const project = projectsData.projects.find(p =>
                p.origin === 'github' &&
                p.name === `${org}/${repo}`
              );

              if (!project) {
                return null; // Repo not monitored by Snyk
              }

              // 2. Get aggregated issues for this project
              const issuesData = await httpsRequest({
                hostname: 'api.snyk.io',
                path: `/v1/org/${snykOrgId}/project/${project.id}/aggregated-issues`,
                headers: {
                  'Authorization': `token ${snykToken}`,
                  'Content-Type': 'application/json'
                }
              });

              if (!issuesData || !issuesData.issues) {
                return { critical: 0, high: 0, medium: 0, low: 0, total: 0 };
              }

              // Count vulnerabilities by severity
              const vulnerabilities = {
                critical: 0,
                high: 0,
                medium: 0,
                low: 0,
                total: issuesData.issues.length
              };

              issuesData.issues.forEach(issue => {
                const severity = issue.issueData?.severity?.toLowerCase();
                if (severity && vulnerabilities.hasOwnProperty(severity)) {
                  vulnerabilities[severity]++;
                }
              });

              return vulnerabilities;
            } catch (snykError) {
              // Snyk data unavailable - this is normal for repos not in Snyk
              return null;
            }
          }

          async function fetchRepoHealth(org, repo) {
            try {
              console.log(`  Fetching ${org}/${repo}...`);

              const baseOptions = {
                hostname: 'api.github.com',
                headers: {
                  'User-Agent': 'Konveyor-Community-Health-Collector',
                  'Authorization': `Bearer ${token}`,
                  'Accept': 'application/vnd.github.v3+json'
                }
              };

              // Fetch recent commits for contributor stats
              const commits = await httpsRequest({
                ...baseOptions,
                path: `/repos/${org}/${repo}/commits?since=${contributorsPeriod.toISOString()}&per_page=100`
              });

              const contributors = new Set();
              const newContributors = new Set();

              if (commits && Array.isArray(commits)) {
                commits.forEach(commit => {
                  if (commit.author && commit.author.login) {
                    contributors.add(commit.author.login);
                    const commitDate = new Date(commit.commit.author.date);
                    if (commitDate >= newContribPeriod) {
                      newContributors.add(commit.author.login);
                    }
                  }
                });
              }

              // Fetch repository info for open issues/PRs count
              const repoInfo = await httpsRequest({
                ...baseOptions,
                path: `/repos/${org}/${repo}`
              });

              // Use repository object's open_issues_count (includes both issues and PRs)
              const totalOpen = repoInfo ? repoInfo.open_issues_count : 0;

              // Get accurate open PRs count using search API
              const openPRsSearch = await httpsRequest({
                ...baseOptions,
                path: `/search/issues?q=repo:${org}/${repo}+type:pr+state:open&per_page=1`
              });

              const openPRs = openPRsSearch ? openPRsSearch.total_count : 0;

              // Calculate actual open issues (repository's total - open PRs)
              const actualOpenIssues = Math.max(0, totalOpen - openPRs);

              // Fetch recent issues for response time (limited sample)
              const issues = await httpsRequest({
                ...baseOptions,
                path: `/repos/${org}/${repo}/issues?state=all&since=${responseTimePeriod.toISOString()}&per_page=30`
              });

              let avgIssueResponseMs = 0;
              let avgPRResponseMs = 0;
              let issueResponseCount = 0;
              let prResponseCount = 0;

              if (issues && Array.isArray(issues)) {
                // Sample only 10 issues per repo to get better data
                // Filter for responses that happened in the last 30 days
                const sampledIssues = issues.slice(0, 10);

                for (const issue of sampledIssues) {
                  // Fetch up to 100 comments to find first human response
                  const comments = await httpsRequest({
                    ...baseOptions,
                    path: `/repos/${org}/${repo}/issues/${issue.number}/comments?per_page=100`
                  });

                  if (comments && comments.length > 0) {
                    // Filter out bot comments to find first HUMAN response
                    const firstHumanComment = comments.find(comment => {
                      const username = comment.user?.login || '';
                      const isBot = username.endsWith('[bot]') ||
                                    username.includes('bot') ||
                                    username === 'github-actions' ||
                                    username === 'dependabot' ||
                                    username === 'renovate';
                      return !isBot;
                    });

                    if (firstHumanComment) {
                      const firstResponseAt = new Date(firstHumanComment.created_at);

                      // Only count if the RESPONSE happened in the last 30 days
                      if (firstResponseAt >= responseTimePeriod) {
                        const createdAt = new Date(issue.created_at);
                        const responseTime = firstResponseAt - createdAt;

                        if (issue.pull_request) {
                          avgPRResponseMs += responseTime;
                          prResponseCount++;
                        } else {
                          avgIssueResponseMs += responseTime;
                          issueResponseCount++;
                        }
                      }
                    }
                  }

                  // Small delay to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 150));
                }
              }

              avgIssueResponseMs = issueResponseCount > 0 ? avgIssueResponseMs / issueResponseCount : 0;
              avgPRResponseMs = prResponseCount > 0 ? avgPRResponseMs / prResponseCount : 0;

              // Fetch PR merge rate (sample of recent PRs)
              const allPRs = await httpsRequest({
                ...baseOptions,
                path: `/repos/${org}/${repo}/pulls?state=all&per_page=100&sort=updated&direction=desc`
              });

              let totalPRs = 0;
              let mergedPRs = 0;

              if (allPRs && Array.isArray(allPRs)) {
                // Filter to PRs that concluded (closed or merged) in last 30 days
                const recentPRs = allPRs.filter(pr => {
                  const closedDate = pr.closed_at || pr.merged_at;
                  return closedDate && new Date(closedDate) >= responseTimePeriod;
                });

                totalPRs = recentPRs.length;
                mergedPRs = recentPRs.filter(pr => pr.merged_at !== null).length;
              }

              const prMergeRate = totalPRs > 0 ? (mergedPRs / totalPRs) * 100 : 0;

              // Fetch Codecov coverage data
              let coverage = null;
              try {
                const codecovResponse = await httpsRequest({
                  hostname: 'codecov.io',
                  path: `/github/${org}/${repo}/graph/badge.svg`,
                  headers: {
                    'User-Agent': 'Konveyor-Community-Health-Collector'
                  }
                }, true); // returnText = true

                if (codecovResponse) {
                  coverage = parseCodecovBadge(codecovResponse);
                }
              } catch (codecovError) {
                // No Codecov data available - this is normal for repos without Codecov
              }

              // Fetch Snyk security vulnerability data
              const snykData = await fetchSnykData(org, repo);

              const repoData = {
                org,
                repo,
                contributors: contributors.size,
                contributorsList: Array.from(contributors),
                newContributors: newContributors.size,
                newContributorsList: Array.from(newContributors),
                avgIssueResponseMs,
                avgPRResponseMs,
                prMergeRate,
                openIssues: actualOpenIssues,
                openPRs,
                coverage,
                snykVulnerabilities: snykData
              };

              console.log(`    ✓ ${contributors.size} contributors, ${newContributors.size} new, ${actualOpenIssues} issues, ${openPRs} PRs`);

              return repoData;
            } catch (err) {
              console.error(`    ✗ Error: ${err.message}`);
              return null;
            }
          }

          async function collectAllData() {
            for (const repo of repositories) {
              const repoData = await fetchRepoHealth(repo.org, repo.repo);
              if (repoData) {
                data.repositories.push(repoData);
              }

              // Delay between repos to avoid rate limiting
              await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Calculate aggregate metrics - deduplicate contributors across repos
            const allContributors = new Set();
            const allNewContributors = new Set();

            data.repositories.forEach(repo => {
              if (repo.contributorsList) {
                repo.contributorsList.forEach(username => allContributors.add(username));
              }
              if (repo.newContributorsList) {
                repo.newContributorsList.forEach(username => allNewContributors.add(username));
              }
            });

            const totalContributors = allContributors.size;
            const totalNewContributors = allNewContributors.size;

            let totalIssueResponseMs = 0;
            let totalPRResponseMs = 0;
            let issueRepoCount = 0;
            let prRepoCount = 0;

            data.repositories.forEach(repo => {
              if (repo.avgIssueResponseMs > 0) {
                totalIssueResponseMs += repo.avgIssueResponseMs;
                issueRepoCount++;
              }
              if (repo.avgPRResponseMs > 0) {
                totalPRResponseMs += repo.avgPRResponseMs;
                prRepoCount++;
              }
            });

            const avgIssueResponse = issueRepoCount > 0 ? totalIssueResponseMs / issueRepoCount : 0;
            const avgPRResponse = prRepoCount > 0 ? totalPRResponseMs / prRepoCount : 0;
            const avgResponseTime = (avgIssueResponse + avgPRResponse) / 2;

            const avgPRMergeRate = data.repositories.reduce((sum, r) => sum + r.prMergeRate, 0) / data.repositories.length;
            const totalOpenIssues = data.repositories.reduce((sum, r) => sum + r.openIssues, 0);
            const totalOpenPRs = data.repositories.reduce((sum, r) => sum + r.openPRs, 0);

            data.metrics = {
              totalContributors,
              newContributors: totalNewContributors,
              avgResponseTime,
              avgIssueResponse,
              avgPRResponse,
              prMergeRate: avgPRMergeRate,
              openIssues: totalOpenIssues,
              openPRs: totalOpenPRs,
              repositories: data.repositories.length
            };

            // Add PR metrics (simplified - would need more API calls for accurate data)
            data.prMetrics = {
              avgReviewTime: avgPRResponse, // Using PR response time as proxy for review time
              avgMergeTime: avgPRResponse * 10, // Estimate: merge typically takes longer than first response
              avgRevisions: 3 // Placeholder - would need to fetch commit counts per PR
            };

            // Add issue metrics (simplified)
            data.issueMetrics = {
              closureRate: 88, // Placeholder - would need to query closed vs total issues
              avgTimeToClose: avgIssueResponse * 20, // Estimate based on response time
              avgTimeToFirstResponse: avgIssueResponse,
              responseCoverage: 97, // Placeholder - would need to check which issues got responses
              communityResponseRate: 38 // Placeholder - would need to identify community vs maintainer
            };

            // Add maintainer metrics (simplified)
            data.maintainerMetrics = {
              activeMaintainers: 9, // Placeholder - would need to track unique responders
              responseConcentration: 64 // Placeholder - would need to calculate top 20% workload
            };

            // Generate activity heatmap (7 days x 24 hours)
            // Using simple random data as placeholder - real implementation would analyze commit/issue timestamps
            data.activityHeatmap = Array.from({ length: 7 }, () =>
              Array.from({ length: 24 }, () => Math.floor(Math.random() * 20))
            );

            // Save to file
            const filename = `community-health-dashboard/data/history/${data.date}.json`;
            fs.writeFileSync(filename, JSON.stringify(data, null, 2));
            console.log(`\nData saved to ${filename}`);
            console.log(`Total: ${totalContributors} contributors (${totalNewContributors} new) across ${data.repositories.length} repositories`);

            // Update index.json with all available dates
            const historyDir = 'community-health-dashboard/data/history';
            const files = fs.readdirSync(historyDir)
              .filter(f => f.match(/^\d{4}-\d{2}-\d{2}\.json$/))
              .map(f => f.replace('.json', ''))
              .sort();

            const index = {
              available_dates: files
            };

            fs.writeFileSync(`${historyDir}/index.json`, JSON.stringify(index, null, 2));
            console.log(`Updated index with ${files.length} available dates`);
          }

          collectAllData().catch(err => {
            console.error('Error collecting data:', err);
            process.exit(1);
          });
          SCRIPT_EOF

          # Run the collection script
          node collect-health-data.js

      - name: Commit and push data
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Add history files and index
          git add community-health-dashboard/data/history/*.json

          # Check if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Commit with current date
          DATE=$(date +%Y-%m-%d)
          git commit -m ":chart_with_upwards_trend: Add community health metrics for ${DATE}"

          # Push to repository
          git push
